"""
    logir(ir, ci, sv)

Log the IR code of a function if it is in the Main module.
"""
function logir(ir, _, sv)
    sv.inlining.interp.options.log_ir || return (ir, false)

    # Only log functions in the Main module
    if nameof(sv.src.parent.def.module) == :Main
        println("Function: ", sv.src.parent.def)
        println(ir)
    end

    return (ir, :log)
end


"""
    pass_group(pm::Core.Compiler.PassManager) 

Creates a closure with a valid optimization pass signature from
a pass manager object, which runs the full pipeline defined by
the pass manager when executed.
"""
function pass_group(pm::CC.PassManager)
    return (ir::IRCode, ci::CC.CodeInfo, sv::OptimizationState) -> CC.run_passes(pm, ir, ci, sv)
end


"""
    register_first_standard_pipeline(pm::Core.Compiler.PassManager)

Register all the required optimization passes for the standard
optimization pipeline used by the Julia compiler. 
"""
function register_first_standard_pipeline!(pm::CC.PassManager)
    CC.register_pass!(pm, "slot2reg", CC.slot2reg |> CC.attachsymbol(:slot2reg))
    CC.register_pass!(pm, "compact 1", CC.compactpass! |> CC.attachsymbol(:compact1))

    CC.register_pass!(pm, "Inlining", CC.inliningpass! |> CC.attachsymbol(:inlining))
    CC.register_pass!(pm, "compact 2", CC.compactpass! |> CC.attachsymbol(:compact2))

    CC.register_pass!(pm, "SROA", CC.sroapass! |> CC.attachsymbol(:sroa))
    CC.register_pass!(pm, "ADCE", CC.adcepass! |> CC.setsymbol(:adce))
    CC.register_condpass!(pm, "compact 3", :adce, CC.compactcfgpass! |> CC.attachsymbol(:compact3))
end


"""
    register_second_standard_pipeline(pm::Core.Compiler.PassManager)

Register a simplified version of the standard Julia optimization
passes to be used after the e-graph rewrite optimizations. Inlining
is not needed here anymore as that already happens inside the
fixedpoint loop.
"""
function register_second_standard_pipeline!(pm::CC.PassManager)
    CC.register_pass!(pm, "SROA 2", CC.sroapass! |> CC.attachsymbol(:sroa2))
    CC.register_pass!(pm, "ADCE 2", CC.adcepass! |> CC.setsymbol(:adce2))
    CC.register_condpass!(pm, "compact 4", :adce2, CC.compactcfgpass! |> CC.attachsymbol(:compact4))
end


"""
    rewrite_fixedpoint_pass(ir, ci, sv)

This function implements the body of the fixedpoint
e-graph rewrite loop. It first performs the e-graph
rewriting, followed by an optional compact pass.
Afterwards it performs the cleanup followed by an
optional inlining pass and another compact pass.
"""
function rewrite_fixedpoint_pass()
    pm = CC.PassManager()

    CC.register_pass!(pm, "rewrite", perform_rewrites! |> CC.setsymbol(:rewrite))
    CC.register_condpass!(pm, "rewrite compact", :rewrite, CC.compactpass! |> CC.attachsymbol(:rewritecompact1))

    CC.register_pass!(pm, "cleanup", cleanup_wrappers! |> CC.setsymbol(:cleanup))

    CC.register_condpass!(pm, "rewrite inline", [:rewrite, :cleanup], CC.inliningpass! |> CC.attachsymbol(:rewriteinlining))
    CC.register_condpass!(pm, "compact", [:rewrite, :cleanup], CC.compactpass! |> CC.attachsymbol(:rewritecompact2))

    return pm
end


"""
    build_optimization_pipeline()

Construct the full e-graph optimization pipeline. This
function returns a `Core.Compiler.PassManager` object.
"""
function build_optimization_pipeline()
    pm = CC.PassManager()

    register_first_standard_pipeline!(pm)
    CC.register_fixedpointpass!(pm, "fixed point", [:rewrite, :cleanup],
        rewrite_fixedpoint_pass())
    register_second_standard_pipeline!(pm)

    # Log the result of the optimizations
    CC.register_pass!(pm, "log", logir)

    if CC.is_asserts()
        CC.register_pass!(pm, "verify", (ir, _, sv) -> begin
            CC.verify_ir(ir, true, false,
                CC.optimizer_lattice(sv.inlining.interp))
            CC.verify_linetable(ir.linetable)
            return (ir, :verify)
        end)
    end

    pm
end


"""
A global dictionary used to store execution times and execution
counts of the major stages of the optimization pipeline.
"""
const STAGE_TIMES = OrderedDict{Symbol,Tuple{Float64,Int}}()


"""
    time(name, pass)

A wrapper pass that times the execution time of the inner pass
and stores the resulting time.
"""
function time(name, pass)
    function (ir, ci, sv)
        result = @timed pass(ir, ci, sv)

        if !haskey(STAGE_TIMES, name)
            STAGE_TIMES[name] = (0.0, 0)
        end

        e = STAGE_TIMES[name]
        STAGE_TIMES[name] = (e[1] + result.time, e[2] + 1)

        result.value
    end
end


"""
    print_pipeline_timings()

Print the timing information for the timing data
generated by the timing optimization pipeline.
"""
function print_pipeline_timings()
    for (name, (time, count)) in STAGE_TIMES
        println(name, ": ", time / count, " (", count, " runs)")
    end
end


"""
    clear_pipeline_timings()

Clear the measured timing data for the timing optimization
pipeline.
"""
function clear_pipeline_timings()
    empty!(STAGE_TIMES)
end


"""
    build_timing_optimization_pipeline()

This function constructs a special optimization
pipeline that measures the execution time of the
three major stages in the pipeline (original pipeline 1,
rewrite fixed point, and original pipeline 2).
"""
function build_timing_pipeline()
    pm = CC.PassManager()

    CC.register_pass!(pm, "standard opt pipeline",
        time(:default1, pass_group(
            let pm = CC.PassManager()
                register_first_standard_pipeline!(pm)
                pm
            end
        ))
    )

    # This is not the most elegant solution but as a fixedpoint pass does not
    # take a single pass but a full pass manager, we can't just use the time
    # wrapper used in the other two parts.
    CC.register_pass!(pm, "fixed point timing",
        time(:fixedpoint, pass_group(
            let pm = CC.PassManager()
                CC.register_fixedpointpass!(pm, "fixed point", [:rewrite, :cleanup],
                    rewrite_fixedpoint_pass())
                pm     
            end
        ))
    )

    CC.register_pass!(pm, "standard opt pipeline",
        time(:default2, pass_group(
            let pm = CC.PassManager()
                register_second_standard_pipeline!(pm)
                pm
            end
        ))
    )

    # Log the result of the optimizations
    CC.register_pass!(pm, "log", logir)

    if CC.is_asserts()
        CC.register_pass!(pm, "verify", (ir, _, sv) -> begin
            CC.verify_ir(ir, true, false,
                CC.optimizer_lattice(sv.inlining.interp))
            CC.verify_linetable(ir.linetable)
            return (ir, :verify)
        end)
    end

    return pm
end
