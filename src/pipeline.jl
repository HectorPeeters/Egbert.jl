"""
    logir(ir, ci, sv)

Log the IR code of a function if it is in the Main module.
"""
function logir(ir, _, sv)
    sv.inlining.interp.options.log_ir || return (ir, false)

    # Only log functions in the Main module
    if nameof(sv.src.parent.def.module) == :Main
        println("Function: ", sv.src.parent.def)
        println(ir)
    end

    return ir |> pass_changed
end


"""
    pass_changed(x)

Helper function to indicate that a pass has changed the IR code.
"""
pass_changed(x) = (x, true)


"""
    pass_group(pm::Core.Compiler.PassManager) 

Creates a closure with a valid optimization pass signature from
a pass manager object, which runs the full pipeline defined by
the pass manager when executed.
"""
function pass_group(pm::CC.PassManager)
    return (ir::IRCode, ci::CC.CodeInfo, sv::OptimizationState) -> CC.run_passes(pm, ir, ci, sv)
end


"""
    register_first_standard_pipeline(pm::Core.Compiler.PassManager)

Register all the required optimization passes for the standard
optimization pipeline used by the Julia compiler. 
"""
function register_first_standard_pipeline!(pm::CC.PassManager)
    # Perform initial conversion to IRCode
    CC.register_pass!(pm, "slot2reg", CC.slot2reg)
    CC.register_condpass!(pm, "compact 1", (ir, _, _) ->
        CC.compact!(ir) |> pass_changed)

    # Perform first pass of normal optimization pipeline
    CC.register_pass!(pm, "inlining", (ir, ci, sv) ->
        CC.ssa_inlining_pass!(ir, sv.inlining, ci.propagate_inbounds))
    CC.register_pass!(pm, "compact 2", (ir, _, _) ->
        CC.compact!(ir) |> pass_changed)

    CC.register_pass!(pm, "SROA", (ir, _, sv) ->
        CC.sroa_pass!(ir, sv.inlining) |> pass_changed)
    CC.register_pass!(pm, "ADCE", (ir, _, sv) ->
        CC.adce_pass!(ir, sv.inlining))
    CC.register_condpass!(pm, "compact 3", (ir, _, _) ->
        CC.compact!(ir, true) |> pass_changed)
end


"""
    register_second_standard_pipeline(pm::Core.Compiler.PassManager)

Register a simplified version of the standard Julia optimization
passes to be used after the e-graph rewrite optimizations. Inlining
is not needed here anymore as that already happens inside the
fixedpoint loop.
"""
function register_second_standard_pipeline!(pm::CC.PassManager)
    CC.register_condpass!(pm, "SROA", (ir, _, sv) ->
        CC.sroa_pass!(ir, sv.inlining) |> pass_changed)
    CC.register_condpass!(pm, "ADCE", (ir, _, sv) ->
        CC.adce_pass!(ir, sv.inlining))
    CC.register_condpass!(pm, "compact 4", (ir, _, _) ->
        CC.compact!(ir, true) |> pass_changed)
end


"""
    rewrite_fixedpoint_pass(ir, ci, sv)

This function implements the body of the fixedpoint
e-graph rewrite loop. It first performs the e-graph
rewriting, followed by an optional compact pass.
Afterwards it performs the cleanup followed by an
optional inlining pass and another compact pass.
"""
function rewrite_fixedpoint_pass(ir, ci, sv)
    # Perform rewrite optimizations
    ir, rewrote = perform_rewrites!(ir, ci, sv)
    if rewrote
        ir = CC.compact!(ir, true)
    end

    # Clean up calls to wrapper methods
    ir, cleanedup = cleanup_wrappers!(ir, ci, sv)

    # Perform inlining and compact if we were able to clean up
    if rewrote || cleanedup
        ir, _ = CC.ssa_inlining_pass!(ir, sv.inlining, ci.propagate_inbounds)
        ir = CC.compact!(ir)
    end

    return ir, (rewrote || cleanedup)
end


"""
    build_optimization_pipeline()

Construct the full e-graph optimization pipeline. This
function returns a `Core.Compiler.PassManager` object.
"""
function build_optimization_pipeline()
    pm = CC.PassManager()

    register_first_standard_pipeline!(pm)
    CC.register_fixedpointpass!(pm, "fixed point", rewrite_fixedpoint_pass)
    register_second_standard_pipeline!(pm)

    # Log the result of the optimizations
    CC.register_pass!(pm, "log", logir)

    if CC.is_asserts()
        CC.register_pass!(pm, "verify", (ir, _, sv) -> begin
            CC.verify_ir(ir, true, false,
                CC.optimizer_lattice(sv.inlining.interp))
            CC.verify_linetable(ir.linetable)
            return ir |> pass_changed
        end)
    end

    pm
end


"""
A global dictionary used to store execution times and execution
counts of the major stages of the optimization pipeline.
"""
const STAGE_TIMES = OrderedDict{String,Tuple{Float64,Int}}()


"""
    time(name, pass)

A wrapper pass that times the execution time of the inner pass
and stores the resulting time.
"""
function time(name, pass)
    function (ir, ci, sv)
        result = @timed pass(ir, ci, sv)

        if !haskey(STAGE_TIMES, name)
            STAGE_TIMES[name] = (0.0, 0)
        end

        e = STAGE_TIMES[name]
        STAGE_TIMES[name] = (e[1] + result.time, e[2] + 1)

        result.value
    end
end


"""
    print_pipeline_timings()

Print the timing information for the timing data
generated by the timing optimization pipeline.
"""
function print_pipeline_timings()
    for (name, (time, count)) in STAGE_TIMES
        println(name, ": ", time / count, " (", count, " runs)")
    end
end


"""
    clear_pipeline_timings()

Clear the measured timing data for the timing optimization
pipeline.
"""
function clear_pipeline_timings()
    empty!(STAGE_TIMES)
end


"""
    build_timing_optimization_pipeline()

This function constructs a special optimization
pipeline that measures the execution time of the
three major stages in the pipeline (original pipeline 1,
rewrite fixed point, and original pipeline 2).
"""
function build_timing_optimization_pipeline()
    pm = CC.PassManager()

    CC.register_pass!(pm, "standard opt pipeline",
        time("default1", pass_group(
            let pm = CC.PassManager()
                register_first_standard_pipeline!(pm)
                pm
            end
        ))
    )

    CC.register_fixedpointpass!(pm, "fixed point",
        time("fixedpoint", rewrite_fixedpoint_pass))

    CC.register_pass!(pm, "standard opt pipeline",
        time("default2", pass_group(
            let pm = CC.PassManager()
                register_second_standard_pipeline!(pm)
                pm
            end
        ))
    )

    # Log the result of the optimizations
    CC.register_pass!(pm, "log", logir)

    if CC.is_asserts()
        CC.register_pass!(pm, "verify", (ir, _, sv) -> begin
            CC.verify_ir(ir, true, false,
                CC.optimizer_lattice(sv.inlining.interp))
            CC.verify_linetable(ir.linetable)
            return ir |> pass_changed
        end)
    end

    return pm
end
