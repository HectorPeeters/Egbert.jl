"""
    get_impl_function_name(func_name)

Get the name of the implementation function for a given function name.
Generally, this is of the format `impl_<func_name>` but in some cases
(e.g. `Base.:+`) this would not work. This is currently not implemented.
"""
function get_impl_function_name(func_name)
    if func_name isa Expr
        # NOTE: Namespaced function definitions such as `Base.:+` are not supported due to
        #       a pattern matching bug in Metatheory 2.0. Implementation for all different
        #       cases of namespaced or qualified function patterns and expressions is
        #       ongoing in the version 3 beta.
        return error("TODO: get the implementation function name for cases like `Base.:+`")
    end

    return Symbol("impl_", func_name)
end


"""
    generate_wrapper_fn(func::Expr, ignore_effects::Bool)

Generate two functions, one implementation function with the original 
body, one wrapper function that is marked as @noinline. Additionally,
the side-effects of the wrapper function can be ignored, this allows
more optimizations to take place during the e-graph stage.
"""
function generate_wrapper_fn(func::Expr, ignore_effects::Bool)
    # If a return type isn't included in the function, the name of the function
    # is nested one additional level. We need the return type to be explicitly
    # stated as that information is lost when using the `Base.compilerbarrier`.
    if func.args[begin].args[begin] isa Symbol
        return error("Please add a return type to the function")
    end

    # Full signature of function including name and return type
    signature = func.args[begin]
    # Signature of function without return type
    signature_noret = signature.args[begin]

    func_name = signature_noret.args[begin]
    args = signature_noret.args[2:end]
    ret_type = signature.args[2]

    # Change the name of the implementation function
    func_name_impl = get_impl_function_name(func_name)
    func.args[begin].args[begin].args[begin] = func_name_impl

    # Return a wrapper around the function that encapsulates the original 
    # implementation
    if ignore_effects

        # Assume effect_free when ignoring side-effects
        return esc(quote
            $(func)

            @noinline Base.@assume_effects :effect_free function $func_name($(args...))::$ret_type
                return $(func_name_impl)($(args...))
            end
        end)
    end

    # Generate a normal wrapper function
    return esc(quote
        $(func)

        @noinline function $func_name($(args...))::$ret_type
            return $(func_name_impl)($(args...))
        end
    end)
end


"""
    rewritetarget(func::Expr)

Mark a function to be used in the egraph optimizations. This creates a wrapper
function with the original name and a separate implementation function with a
name generated by `get_impl_function_name`.
"""
macro rewritetarget(func::Expr)
    generate_wrapper_fn(func, false)
end


"""
    rewritetarget_ef(func::Expr)
    
Very similar to `rewritetarget(func::Expr)`, the only difference is that this
version generates an side-effect free wrapper function.
"""
macro rewritetarget_ef(func::Expr)
    generate_wrapper_fn(func, true)
end
